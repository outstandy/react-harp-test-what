<!DOCTYPE html><html><title>Hometown</title><link rel="stylesheet" href="/scss/main.css"><script src="https://fb.me/react-0.14.7.js"></script><script src="https://fb.me/react-dom-0.14.7.js"></script><script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script><script src="https://npmcdn.com/jquery@3.1.0/dist/jquery.min.js"></script><script src="https://npmcdn.com/remarkable@1.6.2/dist/remarkable.min.js"></script><body><nav><div class="grid"><div class="row"><div class="grid-1-1"><a href="#" class="titling type-300 pink">Hometown</a></div></div></div></nav><h1>yargs</h1><p>Yargs be a node.js library fer hearties tryin&#39; ter parse optstrings.</p>
<p>With yargs, ye be havin&#39; a map that leads straight to yer treasure! Treasure of course, being a simple option hash.</p>
<p><a href="https://travis-ci.org/yargs/yargs"><img src="https://img.shields.io/travis/yargs/yargs/master.svg" alt="Build Status"></a>
<a href="https://gemnasium.com/yargs/yargs"><img src="https://img.shields.io/gemnasium/yargs/yargs.svg" alt="Dependency Status"></a>
<a href="https://coveralls.io/github/yargs/yargs"><img src="https://img.shields.io/coveralls/yargs/yargs.svg" alt="Coverage Status"></a>
<a href="https://www.npmjs.com/package/yargs"><img src="https://img.shields.io/npm/v/yargs.svg" alt="NPM version"></a>
<a href="https://ci.appveyor.com/project/bcoe/yargs-ljwvf"><img src="https://img.shields.io/appveyor/ci/bcoe/yargs-ljwvf/master.svg?label=Windows%20Tests" alt="Windows Tests"></a>
<a href="http://standardjs.com/"><img src="https://img.shields.io/badge/code%20style-standard-brightgreen.svg" alt="js-standard-style"></a>
<a href="https://github.com/conventional-changelog/standard-version"><img src="https://img.shields.io/badge/release-standard%20version-brightgreen.svg" alt="standard-version"></a></p>
<blockquote>
<p>Yargs is the official successor to optimist. Please feel free to submit issues and pull requests. If you&#39;d like to contribute and don&#39;t know where to start, have a look at <a href="https://github.com/yargs/yargs/issues">the issue list</a> :)</p>
</blockquote>
<h1>examples</h1><h2>With yargs, the options be just a hash!</h2><p>plunder.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;).argv;

if (argv.ships &gt; 3 &amp;&amp; argv.distance &lt; 53.5) {
    console.log(&#39;Plunder more riffiwobbles!&#39;);
} else {
    console.log(&#39;Retreat from the xupptumblers!&#39;);
}
</code></pre>
<hr>
<pre><code>$ ./plunder.js --ships=4 --distance=22
Plunder more riffiwobbles!

$ ./plunder.js --ships 12 --distance 98.7
Retreat from the xupptumblers!
</code></pre><p><img src="http://i.imgur.com/4WFGVJ9.png" alt="Joe was one optimistic pirate."></p>
<h2>But don&#39;t walk the plank just yet! There be more! You can do short options:</h2><p>short.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;).argv;
console.log(&#39;(%d,%d)&#39;, argv.x, argv.y);
</code></pre>
<hr>
<pre><code>$ ./short.js -x 10 -y 21
(10,21)
</code></pre><h2>And booleans, both long, short, and even grouped:</h2><p>bool.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;).argv;

if (argv.s) {
    process.stdout.write(argv.fr ? &#39;Le perroquet dit: &#39; : &#39;The parrot says: &#39;);
}
console.log(
    (argv.fr ? &#39;couac&#39; : &#39;squawk&#39;) + (argv.p ? &#39;!&#39; : &#39;&#39;)
);
</code></pre>
<hr>
<pre><code>$ ./bool.js -s
The parrot says: squawk

$ ./bool.js -sp
The parrot says: squawk!

$ ./bool.js -sp --fr
Le perroquet dit: couac!
</code></pre><h2>And non-hyphenated options too! Just use <code>argv._</code>!</h2><p>nonopt.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;).argv;
console.log(&#39;(%d,%d)&#39;, argv.x, argv.y);
console.log(argv._);
</code></pre>
<hr>
<pre><code>$ ./nonopt.js -x 6.82 -y 3.35 rum
(6.82,3.35)
[ &#39;rum&#39; ]

$ ./nonopt.js &quot;me hearties&quot; -x 0.54 yo -y 1.12 ho
(0.54,1.12)
[ &#39;me hearties&#39;, &#39;yo&#39;, &#39;ho&#39; ]
</code></pre><h2>Yargs even counts your booleans!</h2><p>count.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;)
    .count(&#39;verbose&#39;)
    .alias(&#39;v&#39;, &#39;verbose&#39;)
    .argv;

VERBOSE_LEVEL = argv.verbose;

function WARN()  { VERBOSE_LEVEL &gt;= 0 &amp;&amp; console.log.apply(console, arguments); }
function INFO()  { VERBOSE_LEVEL &gt;= 1 &amp;&amp; console.log.apply(console, arguments); }
function DEBUG() { VERBOSE_LEVEL &gt;= 2 &amp;&amp; console.log.apply(console, arguments); }

WARN(&quot;Showing only important stuff&quot;);
INFO(&quot;Showing semi-important stuff too&quot;);
DEBUG(&quot;Extra chatty mode&quot;);
</code></pre>
<hr>
<pre><code>$ node count.js
Showing only important stuff

$ node count.js -v
Showing only important stuff
Showing semi-important stuff too

$ node count.js -vv
Showing only important stuff
Showing semi-important stuff too
Extra chatty mode

$ node count.js -v --verbose
Showing only important stuff
Showing semi-important stuff too
Extra chatty mode
</code></pre><h2>Tell users how to use yer options and make demands.</h2><p>area.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;)
    .usage(&#39;Usage: $0 -w [num] -h [num]&#39;)
    .demand([&#39;w&#39;,&#39;h&#39;])
    .argv;

console.log(&quot;The area is:&quot;, argv.w * argv.h);
</code></pre>
<hr>
<pre><code>$ ./area.js -w 55 -h 11
The area is: 605

$ node ./area.js -w 4.91 -w 2.51
Usage: area.js -w [num] -h [num]

Options:
  -w  [required]
  -h  [required]

Missing required arguments: h
</code></pre><h2>After yer demands have been met, demand more! Ask for non-hyphenated arguments!</h2><p>demand_count.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;)
    .demand(2)
    .argv;
console.dir(argv);
</code></pre>
<hr>
<pre><code>$ ./demand_count.js a

Not enough non-option arguments: got 1, need at least 2

$ ./demand_count.js a b
{ _: [ &#39;a&#39;, &#39;b&#39; ], &#39;$0&#39;: &#39;demand_count.js&#39; }

$ ./demand_count.js a b c
{ _: [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ], &#39;$0&#39;: &#39;demand_count.js&#39; }
</code></pre><h2>EVEN MORE SHIVER ME TIMBERS!</h2><p>default_singles.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;)
    .default(&#39;x&#39;, 10)
    .default(&#39;y&#39;, 10)
    .argv
;
console.log(argv.x + argv.y);
</code></pre>
<hr>
<pre><code>$ ./default_singles.js -x 5
15
</code></pre><p>default_hash.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;)
    .default({ x : 10, y : 10 })
    .argv
;
console.log(argv.x + argv.y);
</code></pre>
<hr>
<pre><code>$ ./default_hash.js -y 7
17
</code></pre><h2>And if you really want to get all descriptive about it...</h2><p>boolean_single.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;)
    .boolean(&#39;v&#39;)
    .argv
;
console.dir(argv.v);
console.dir(argv._);
</code></pre>
<hr>
<pre><code>$ ./boolean_single.js -v &quot;me hearties&quot; yo ho
true
[ &#39;me hearties&#39;, &#39;yo&#39;, &#39;ho&#39; ]
</code></pre><p>boolean_double.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;)
    .boolean([&#39;x&#39;,&#39;y&#39;,&#39;z&#39;])
    .argv
;
console.dir([ argv.x, argv.y, argv.z ]);
console.dir(argv._);
</code></pre>
<hr>
<pre><code>$ ./boolean_double.js -x -z one two three
[ true, false, true ]
[ &#39;one&#39;, &#39;two&#39;, &#39;three&#39; ]
</code></pre><h2>Yargs is here to help you...</h2><p>Ye can describe parameters fer help messages and set aliases. Yargs figures
out how ter format a handy help string automatically.</p>
<p>line_count.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;)
    .usage(&#39;Usage: $0 &lt;command&gt; [options]&#39;)
    .command(&#39;count&#39;, &#39;Count the lines in a file&#39;)
    .demand(1)
    .example(&#39;$0 count -f foo.js&#39;, &#39;count the lines in the given file&#39;)
    .demand(&#39;f&#39;)
    .alias(&#39;f&#39;, &#39;file&#39;)
    .nargs(&#39;f&#39;, 1)
    .describe(&#39;f&#39;, &#39;Load a file&#39;)
    .help(&#39;h&#39;)
    .alias(&#39;h&#39;, &#39;help&#39;)
    .epilog(&#39;copyright 2015&#39;)
    .argv;

var fs = require(&#39;fs&#39;);
var s = fs.createReadStream(argv.file);

var lines = 0;
s.on(&#39;data&#39;, function (buf) {
    lines += buf.toString().match(/\n/g).length;
});

s.on(&#39;end&#39;, function () {
    console.log(lines);
});
</code></pre>
<hr>
<pre><code>$ node line_count.js count
Usage: line_count.js &lt;command&gt; [options]

Commands:
  count    Count the lines in a file

Options:
  -f, --file  Load a file        [required]
  -h, --help  Show help           [boolean]

Examples:
  line_count.js count -f foo.js  count the lines in the given file

copyright 2015

Missing required arguments: f

$ node line_count.js count --file line_count.js
26

$ node line_count.js count -f line_count.js
26
</code></pre><h1>methods</h1><p>By itself,</p>
<pre><code class="language-javascript">require(&#39;yargs&#39;).argv
</code></pre>
<p>will use the <code>process.argv</code> array to construct the <code>argv</code> object.</p>
<p>You can pass in the <code>process.argv</code> yourself:</p>
<pre><code class="language-javascript">require(&#39;yargs&#39;)([ &#39;-x&#39;, &#39;1&#39;, &#39;-y&#39;, &#39;2&#39; ]).argv
</code></pre>
<p>or use <code>.parse()</code> to do the same thing:</p>
<pre><code class="language-javascript">require(&#39;yargs&#39;).parse([ &#39;-x&#39;, &#39;1&#39;, &#39;-y&#39;, &#39;2&#39; ])
</code></pre>
<p>The rest of these methods below come in just before the terminating <code>.argv</code>.</p>
<h2><a name="alias"></a>.alias(key, alias)</h2><p>Set key names as equivalent such that updates to a key will propagate to aliases
and vice-versa.</p>
<p>Optionally <code>.alias()</code> can take an object that maps keys to aliases.
Each key of this object should be the canonical version of the option, and each
value should be a string or an array of strings.</p>
<h2>.argv</h2><p>Get the arguments as a plain old object.</p>
<p>Arguments without a corresponding flag show up in the <code>argv._</code> array.</p>
<p>The script name or node command is available at <code>argv.$0</code> similarly to how <code>$0</code>
works in bash or perl.</p>
<p>If <code>yargs</code> is executed in an environment that embeds node and there&#39;s no script name (e.g.
<a href="http://electron.atom.io/">Electron</a> or <a href="http://nwjs.io/">nw.js</a>), it will ignore the first parameter since it
expects it to be the script name. In order to override this behavior, use <code>.parse(process.argv.slice(1))</code>
instead of <code>.argv</code> and the first parameter won&#39;t be ignored.</p>
<h2><a name="array"></a>.array(key)</h2><p>Tell the parser to interpret <code>key</code> as an array. If <code>.array(&#39;foo&#39;)</code> is set,
<code>--foo foo bar</code> will be parsed as <code>[&#39;foo&#39;, &#39;bar&#39;]</code> rather than as <code>&#39;foo&#39;</code>.</p>
<h2><a name="boolean"></a>.boolean(key)</h2><p>Interpret <code>key</code> as a boolean. If a non-flag option follows <code>key</code> in
<code>process.argv</code>, that string won&#39;t get set as the value of <code>key</code>.</p>
<p><code>key</code> will default to <code>false</code>, unless a <code>default(key, undefined)</code> is
explicitly set.</p>
<p>If <code>key</code> is an array, interpret all the elements as booleans.</p>
<h2>.check(fn)</h2><p>Check that certain conditions are met in the provided arguments.</p>
<p><code>fn</code> is called with two arguments, the parsed <code>argv</code> hash and an array of options and their aliases.</p>
<p>If <code>fn</code> throws or returns a non-truthy value, show the thrown error, usage information, and
exit.</p>
<h2><a name="choices"></a>.choices(key, choices)</h2><p>Limit valid values for <code>key</code> to a predefined set of <code>choices</code>, given as an array
or as an individual value.</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .alias(&#39;i&#39;, &#39;ingredient&#39;)
  .describe(&#39;i&#39;, &#39;choose your sandwich ingredients&#39;)
  .choices(&#39;i&#39;, [&#39;peanut-butter&#39;, &#39;jelly&#39;, &#39;banana&#39;, &#39;pickles&#39;])
  .help(&#39;help&#39;)
  .argv
</code></pre>
<p>If this method is called multiple times, all enumerated values will be merged
together. Choices are generally strings or numbers, and value matching is
case-sensitive.</p>
<p>Optionally <code>.choices()</code> can take an object that maps multiple keys to their
choices.</p>
<p>Choices can also be specified as <code>choices</code> in the object given to <code>option()</code>.</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .option(&#39;size&#39;, {
    alias: &#39;s&#39;,
    describe: &#39;choose a size&#39;,
    choices: [&#39;xs&#39;, &#39;s&#39;, &#39;m&#39;, &#39;l&#39;, &#39;xl&#39;]
  })
  .argv
</code></pre>
<h2>.command(cmd, desc, [builder], [handler])</h2><h2>.command(cmd, desc, [module])</h2><h2>.command(module)</h2><p>Document the commands exposed by your application.</p>
<p>Use <code>desc</code> to provide a description for each command your application accepts (the
values stored in <code>argv._</code>).  Set <code>desc</code> to <code>false</code> to create a hidden command.
Hidden commands don&#39;t show up in the help output and aren&#39;t available for
completion.</p>
<p>Optionally, you can provide a <code>builder</code> object to give hints about the
options that your command accepts:</p>
<pre><code class="language-js">yargs.command(&#39;get&#39;, &#39;make a get HTTP request&#39;, {
    url: {
      alias: &#39;u&#39;,
      default: &#39;http://yargs.js.org/&#39;
    }
  })
  .help()
  .argv
</code></pre>
<p>Note that commands will not automatically inherit configuration <em>or</em> options
of their parent context. This means you&#39;ll have to re-apply configuration
if necessary, and make options global manually using the <a href="#global">global</a> method.</p>
<p>Additionally, the <a href="#help"><code>help</code></a> and <a href="#version"><code>version</code></a>
options (if used) <strong>always</strong> apply globally, just like the
<a href="#wrap"><code>.wrap()</code></a> configuration.</p>
<p><code>builder</code> can also be a function. This function is executed
with a <code>yargs</code> instance, and can be used to provide <em>advanced</em> command specific help:</p>
<pre><code class="language-js">yargs.command(&#39;get&#39;, &#39;make a get HTTP request&#39;, function (yargs) {
    return yargs.option(&#39;url&#39;, {
      alias: &#39;u&#39;,
      default: &#39;http://yargs.js.org/&#39;
    })
  })
  .help()
  .argv
</code></pre>
<p>You can also provide a handler function, which will be executed with the
parsed <code>argv</code> object:</p>
<pre><code class="language-js">yargs
  .command(
    &#39;get&#39;,
    &#39;make a get HTTP request&#39;,
    function (yargs) {
      return yargs.option(&#39;u&#39;, {
        alias: &#39;url&#39;,
        describe: &#39;the URL to make an HTTP request to&#39;
      })
    },
    function (argv) {
      console.log(argv.url)
    }
  )
  .help()
  .argv
</code></pre>
<h3>Positional Arguments</h3><p>Commands can accept <em>optional</em> and <em>required</em> positional arguments. Required
positional arguments take the form <code>&lt;foo&gt;</code>, and optional arguments
take the form <code>[bar]</code>. The parsed positional arguments will be populated in
<code>argv</code>:</p>
<pre><code class="language-js">yargs.command(&#39;get &lt;source&gt; [proxy]&#39;, &#39;make a get HTTP request&#39;)
  .help()
  .argv
</code></pre>
<h4>Variadic Positional Arguments</h4><p>The last positional argument can optionally accept an array of
values, by using the <code>..</code> operator:</p>
<pre><code class="language-js">yargs.command(&#39;download &lt;url&gt; [files..]&#39;, &#39;download several files&#39;)
  .help()
  .argv
</code></pre>
<h3>Providing a Command Module</h3><p>For complicated commands you can pull the logic into a module. A module
simply needs to export:</p>
<ul>
<li><code>exports.command</code>: string that executes this command when given on the command line, may contain positional args</li>
<li><code>exports.describe</code>: string used as the description for the command in help text, use <code>false</code> for a hidden command</li>
<li><code>exports.builder</code>: object declaring the options the command accepts, or a function accepting and returning a yargs instance</li>
<li><code>exports.handler</code>: a function which will be passed the parsed argv.</li>
</ul>
<pre><code class="language-js">// my-module.js
exports.command = &#39;get &lt;source&gt; [proxy]&#39;

exports.describe = &#39;make a get HTTP request&#39;

exports.builder = {
  banana: {
    default: &#39;cool&#39;
  },
  batman: {
    default: &#39;sad&#39;
  }
}

exports.handler = function (argv) {
  // do something with argv.
}
</code></pre>
<p>You then register the module like so:</p>
<pre><code class="language-js">yargs.command(require(&#39;my-module&#39;))
  .help()
  .argv
</code></pre>
<p>Or if the module does not export <code>command</code> and <code>describe</code> (or if you just want to override them):</p>
<pre><code class="language-js">yargs.command(&#39;get &lt;source&gt; [proxy]&#39;, &#39;make a get HTTP request&#39;, require(&#39;my-module&#39;))
  .help()
  .argv
</code></pre>
<h2>.commandDir(directory, [opts])</h2><p>Apply command modules from a directory relative to the module calling this method.</p>
<p>This allows you to organize multiple commands into their own modules under a
single directory and apply all of them at once instead of calling
<code>.command(require(&#39;./dir/module&#39;))</code> multiple times.</p>
<p>By default, it ignores subdirectories. This is so you can use a directory
structure to represent your command hierarchy, where each command applies its
subcommands using this method in its builder function. See the example below.</p>
<p>Note that yargs assumes all modules in the given directory are command modules
and will error if non-command modules are encountered. In this scenario, you
can either move your module to a different directory or use the <code>exclude</code> or
<code>visit</code> option to manually filter it out. More on that below.</p>
<p><code>directory</code> is a relative directory path as a string (required).</p>
<p><code>opts</code> is an options object (optional). The following options are valid:</p>
<ul>
<li><p><code>recurse</code>: boolean, default <code>false</code></p>
<p>  Look for command modules in all subdirectories and apply them as a flattened
  (non-hierarchical) list.</p>
</li>
<li><p><code>extensions</code>: array of strings, default <code>[&#39;js&#39;]</code></p>
<p>  The types of files to look for when requiring command modules.</p>
</li>
<li><p><code>visit</code>: function</p>
<p>  A synchronous function called for each command module encountered. Accepts
  <code>commandObject</code>, <code>pathToFile</code>, and <code>filename</code> as arguments. Returns
  <code>commandObject</code> to include the command; any falsy value to exclude/skip it.</p>
</li>
<li><p><code>include</code>: RegExp or function</p>
<p>  Whitelist certain modules. See <a href="https://www.npmjs.com/package/require-directory#whitelisting"><code>require-directory</code> whitelisting</a> for details.</p>
</li>
<li><p><code>exclude</code>: RegExp or function</p>
<p>  Blacklist certain modules. See <a href="https://www.npmjs.com/package/require-directory#blacklisting"><code>require-directory</code> blacklisting</a> for details.</p>
</li>
</ul>
<h3>Example command hierarchy using <code>.commandDir()</code></h3><p>Desired CLI:</p>
<pre><code class="language-sh">$ myapp --help
$ myapp init
$ myapp remote --help
$ myapp remote add base http://yargs.js.org
$ myapp remote prune base
$ myapp remote prune base fork whatever
</code></pre>
<p>Directory structure:</p>
<pre><code>myapp/
├─ cli.js
└─ cmds/
   ├─ init.js
   ├─ remote.js
   └─ remote_cmds/
      ├─ add.js
      └─ prune.js
</code></pre><p>cli.js:</p>
<pre><code class="language-js">#!/usr/bin/env node
require(&#39;yargs&#39;)
  .commandDir(&#39;cmds&#39;)
  .demand(1)
  .help()
  .argv
</code></pre>
<p>cmds/init.js:</p>
<pre><code class="language-js">exports.command = &#39;init [dir]&#39;
exports.desc = &#39;Create an empty repo&#39;
exports.builder = {
  dir: {
    default: &#39;.&#39;
  }
}
exports.handler = function (argv) {
  console.log(&#39;init called for dir&#39;, argv.dir)
}
</code></pre>
<p>cmds/remote.js:</p>
<pre><code class="language-js">exports.command = &#39;remote &lt;command&gt;&#39;
exports.desc = &#39;Manage set of tracked repos&#39;
exports.builder = function (yargs) {
  return yargs.commandDir(&#39;remote_cmds&#39;)
}
exports.handler = function (argv) {}
</code></pre>
<p>cmds/remote_cmds/add.js:</p>
<pre><code class="language-js">exports.command = &#39;add &lt;name&gt; &lt;url&gt;&#39;
exports.desc = &#39;Add remote named &lt;name&gt; for repo at url &lt;url&gt;&#39;
exports.builder = {}
exports.handler = function (argv) {
  console.log(&#39;adding remote %s at url %s&#39;, argv.name, argv.url)
}
</code></pre>
<p>cmds/remote_cmds/prune.js:</p>
<pre><code class="language-js">exports.command = &#39;prune &lt;name&gt; [names..]&#39;
exports.desc = &#39;Delete tracked branches gone stale for remotes&#39;
exports.builder = {}
exports.handler = function (argv) {
  console.log(&#39;pruning remotes %s&#39;, [].concat(argv.name).concat(argv.names).join(&#39;, &#39;))
}
</code></pre>
<h2>.completion([cmd], [description], [fn])</h2><p>Enable bash-completion shortcuts for commands and options.</p>
<p><code>cmd</code>: When present in <code>argv._</code>, will result in the <code>.bashrc</code> completion script
being outputted. To enable bash completions, concat the generated script to your
<code>.bashrc</code> or <code>.bash_profile</code>.</p>
<p><code>description</code>: Provide a description in your usage instructions for the command
that generates bash completion scripts.</p>
<p><code>fn</code>: Rather than relying on yargs&#39; default completion functionality, which
shiver me timbers is pretty awesome, you can provide your own completion
method.</p>
<p>If invoked without parameters, <code>.completion()</code> will make <code>completion</code> the command to output
the completion script.</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .completion(&#39;completion&#39;, function(current, argv) {
    // &#39;current&#39; is the current command being completed.
    // &#39;argv&#39; is the parsed arguments so far.
    // simply return an array of completions.
    return [
      &#39;foo&#39;,
      &#39;bar&#39;
    ];
  })
  .argv;
</code></pre>
<p>You can also provide asynchronous completions.</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .completion(&#39;completion&#39;, function(current, argv, done) {
    setTimeout(function() {
      done([
        &#39;apple&#39;,
        &#39;banana&#39;
      ]);
    }, 500);
  })
  .argv;
</code></pre>
<p>But wait, there&#39;s more! You can return an asynchronous promise.</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .completion(&#39;completion&#39;, function(current, argv, done) {
    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        resolve([&#39;apple&#39;, &#39;banana&#39;])
      }, 10)
    })
  })
  .argv;
</code></pre>
<h2><a name="config"></a>.config([key], [description], [parseFn])</h2><h2>.config(object)</h2><p>Tells the parser that if the option specified by <code>key</code> is passed in, it
should be interpreted as a path to a JSON config file. The file is loaded
and parsed, and its properties are set as arguments.</p>
<p>If invoked without parameters, <code>.config()</code> will make <code>--config</code> the option to pass the JSON config file.</p>
<p>An optional <code>description</code> can be provided to customize the config (<code>key</code>) option
in the usage string.</p>
<p>An optional <code>parseFn</code> can be used to provide a custom parser. The parsing
function must be synchronous, and should return an object containing
key value pairs or an error.</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .config(&#39;settings&#39;, function (configPath) {
    return JSON.parse(fs.readFileSync(configPath, &#39;utf-8&#39;))
  })
  .argv
</code></pre>
<p>You can also pass an explicit configuration <code>object</code>, it will be parsed
and its properties will be set as arguments.</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .config({foo: 1, bar: 2})
  .argv
console.log(argv)
</code></pre>
<pre><code>$ node test.js
{ _: [],
  foo: 1,
  bar: 2,
  &#39;$0&#39;: &#39;test.js&#39; }
</code></pre><h2><a name="count"></a>.count(key)</h2><p>Interpret <code>key</code> as a boolean flag, but set its parsed value to the number of
flag occurrences rather than <code>true</code> or <code>false</code>. Default value is thus <code>0</code>.</p>
<h2><a name="default"></a>.default(key, value, [description])</h2><h2>.defaults(key, value, [description])</h2><p><strong>Note:</strong> The <code>.defaults()</code> alias is deprecated. It will be
removed in the next major version.</p>
<p>Set <code>argv[key]</code> to <code>value</code> if no option was specified in <code>process.argv</code>.</p>
<p>Optionally <code>.default()</code> can take an object that maps keys to default values.</p>
<p>But wait, there&#39;s more! The default value can be a <code>function</code> which returns
a value. The name of the function will be used in the usage string:</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .default(&#39;random&#39;, function randomValue() {
    return Math.random() * 256;
  }).argv;
</code></pre>
<p>Optionally, <code>description</code> can also be provided and will take precedence over
displaying the value in the usage instructions:</p>
<pre><code class="language-js">.default(&#39;timeout&#39;, 60000, &#39;(one-minute)&#39;)
</code></pre>
<h2><a name="demand"></a>.demand(key, [msg | boolean])</h2><h2>.demand(count, [max], [msg])</h2><p>If <code>key</code> is a string, show the usage information and exit if <code>key</code> wasn&#39;t
specified in <code>process.argv</code>.</p>
<p>If <code>key</code> is a number, demand at least as many non-option arguments, which show
up in <code>argv._</code>. A second number can also optionally be provided, which indicates
the maximum number of non-option arguments.</p>
<p>If <code>key</code> is an array, demand each element.</p>
<p>If a <code>msg</code> string is given, it will be printed when the argument is missing,
instead of the standard error message. This is especially helpful for the non-option arguments in <code>argv._</code>.</p>
<p>If a <code>boolean</code> value is given, it controls whether the option is demanded;
this is useful when using <code>.options()</code> to specify command line parameters.</p>
<p>A combination of <code>.demand(1)</code> and <code>.strict()</code> will allow you to require a user to pass at least one command:</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .command(&#39;install&#39;, &#39;tis a mighty fine package to install&#39;)
  .demand(1)
  .strict()
  .argv
</code></pre>
<p>Similarly, you can require a command and arguments at the same time:</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .command(&#39;install&#39;, &#39;tis a mighty fine package to install&#39;)
  .demand(1, [&#39;w&#39;, &#39;m&#39;])
  .strict()
  .argv
</code></pre>
<h2><a name="describe"></a>.describe(key, desc)</h2><p>Describe a <code>key</code> for the generated usage information.</p>
<p>Optionally <code>.describe()</code> can take an object that maps keys to descriptions.</p>
<h2>.detectLocale(boolean)</h2><p>Should yargs attempt to detect the os&#39; locale? Defaults to <code>true</code>.</p>
<h2>.env([prefix])</h2><p>Tell yargs to parse environment variables matching the given prefix and apply
them to argv as though they were command line arguments.</p>
<p>Use the &quot;<strong>&quot; separator in the environment variable to indicate nested options.
(e.g. prefix_nested</strong>foo =&gt; nested.foo)</p>
<p>If this method is called with no argument or with an empty string or with <code>true</code>,
then all env vars will be applied to argv.</p>
<p>Program arguments are defined in this order of precedence:</p>
<ol>
<li>Command line args</li>
<li>Config file</li>
<li>Env var</li>
<li>Configured defaults</li>
</ol>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .env(&#39;MY_PROGRAM&#39;)
  .option(&#39;f&#39;, {
    alias: &#39;fruit-thing&#39;,
    default: &#39;apple&#39;
  })
  .argv
console.log(argv)
</code></pre>
<pre><code>$ node fruity.js
{ _: [],
  f: &#39;apple&#39;,
  &#39;fruit-thing&#39;: &#39;apple&#39;,
  fruitThing: &#39;apple&#39;,
  &#39;$0&#39;: &#39;fruity.js&#39; }
</code></pre><pre><code>$ MY_PROGRAM_FRUIT_THING=banana node fruity.js
{ _: [],
  fruitThing: &#39;banana&#39;,
  f: &#39;banana&#39;,
  &#39;fruit-thing&#39;: &#39;banana&#39;,
  &#39;$0&#39;: &#39;fruity.js&#39; }
</code></pre><pre><code>$ MY_PROGRAM_FRUIT_THING=banana node fruity.js -f cat
{ _: [],
  f: &#39;cat&#39;,
  &#39;fruit-thing&#39;: &#39;cat&#39;,
  fruitThing: &#39;cat&#39;,
  &#39;$0&#39;: &#39;fruity.js&#39; }
</code></pre><p>Env var parsing is disabled by default, but you can also explicitly disable it
by calling <code>.env(false)</code>, e.g. if you need to undo previous configuration.</p>
<h2>.epilog(str)</h2><h2>.epilogue(str)</h2><p>A message to print at the end of the usage instructions, e.g.</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .epilogue(&#39;for more information, find our manual at http://example.com&#39;);
</code></pre>
<h2>.example(cmd, desc)</h2><p>Give some example invocations of your program. Inside <code>cmd</code>, the string
<code>$0</code> will get interpolated to the current script name or node command for the
present script similar to how <code>$0</code> works in bash or perl.
Examples will be printed out as part of the help message.</p>
<h2>.exitProcess(enable)</h2><p>By default, yargs exits the process when the user passes a help flag, uses the
<code>.version</code> functionality, or when validation fails. Calling
<code>.exitProcess(false)</code> disables this behavior, enabling further actions after
yargs have been validated.</p>
<h2>.fail(fn)</h2><p>Method to execute when a failure occurs, rather than printing the failure message.</p>
<p><code>fn</code> is called with the failure message that would have been printed and the
<code>Error</code> instance originally thrown, if any.</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .fail(function (msg, err) {
    if (err) throw err // preserve stack
    console.error(&#39;You broke it!&#39;)
    console.error(msg)
    process.exit(1)
  })
  .argv
</code></pre>
<h2>.getCompletion(args, done);</h2><p>Allows to programmatically get completion choices for any line.</p>
<p><code>args</code>: An array of the words in the command line to complete.</p>
<p><code>done</code>: The callback to be called with the resulting completions.</p>
<p>For example:</p>
<pre><code class="language-js">require(&#39;yargs&#39;)
  .option(&#39;foobar&#39;, {})
  .option(&#39;foobaz&#39;, {})
  .completion()
  .getCompletion([&#39;./test.js&#39;, &#39;--foo&#39;], function (completions) {
    console.log(completions)
  })
</code></pre>
<p>Outputs the same completion choices as <code>./test.js --foo</code><kbd>TAB</kbd>: <code>--foobar</code> and <code>--foobaz</code></p>
<h2><a name="global"></a>.global(globals)</h2><p>Indicate that an option (or group of options) should not be reset when a command
is executed, as an example:</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .option(&#39;a&#39;, {
    alias: &#39;all&#39;,
    default: true
  })
  .option(&#39;n&#39;, {
    alias: &#39;none&#39;,
    default: true
  })
  .command(&#39;foo&#39;, &#39;foo command&#39;, function (yargs) {
    return yargs.option(&#39;b&#39;, {
      alias: &#39;bar&#39;
    })
  })
  .help(&#39;help&#39;)
  .global(&#39;a&#39;)
  .argv
</code></pre>
<p>If the <code>foo</code> command is executed the <code>all</code> option will remain, but the <code>none</code>
option will have been eliminated.</p>
<p><code>help</code>, <code>version</code>, and <code>completion</code> options default to being global.</p>
<h2><a name="group"></a>.group(key(s), groupName)</h2><p>Given a key, or an array of keys, places options under an alternative heading
when displaying usage instructions, e.g.,</p>
<pre><code class="language-js">var yargs = require(&#39;yargs&#39;)([&#39;--help&#39;])
  .help()
  .group(&#39;batman&#39;, &#39;Heroes:&#39;)
  .describe(&#39;batman&#39;, &quot;world&#39;s greatest detective&quot;)
  .wrap(null)
  .argv
</code></pre>
<hr>
<pre><code>Heroes:
  --batman  world&#39;s greatest detective

Options:
  --help  Show help  [boolean]
</code></pre><h2><a name="help"></a>.help([option, [description]])</h2><p>Add an option (e.g. <code>--help</code>) that displays the usage string and exits the
process. If present, the <code>description</code> parameter customizes the description of
the help option in the usage string.</p>
<p>If invoked without parameters, <code>.help()</code> will make <code>--help</code> the option to trigger
help output.</p>
<p>Example:</p>
<pre><code class="language-js">var yargs = require(&quot;yargs&quot;)([&#39;--help&#39;])
  .usage(&quot;$0 -operand1 number -operand2 number -operation [add|subtract]&quot;)
  .help()
  .argv
</code></pre>
<p>Later on, <code>argv</code> can be retrieved with <code>yargs.argv</code>.</p>
<h2>.implies(x, y)</h2><p>Given the key <code>x</code> is set, it is required that the key <code>y</code> is set.</p>
<p>Optionally <code>.implies()</code> can accept an object specifying multiple implications.</p>
<h2>.locale()</h2><p>Return the locale that yargs is currently using.</p>
<p>By default, yargs will auto-detect the operating system&#39;s locale so that
yargs-generated help content will display in the user&#39;s language.</p>
<p>To override this behavior with a static locale, pass the desired locale as a
string to this method (see below).</p>
<h2>.locale(locale)</h2><p>Override the auto-detected locale from the user&#39;s operating system with a static
locale. Note that the OS locale can be modified by setting/exporting the <code>LC_ALL</code>
environment variable.</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .usage(&#39;./$0 - follow ye instructions true&#39;)
  .option(&#39;option&#39;, {
    alias: &#39;o&#39;,
    describe: &quot;&#39;tis a mighty fine option&quot;,
    demand: true
  })
  .command(&#39;run&#39;, &quot;Arrr, ya best be knowin&#39; what yer doin&#39;&quot;)
  .example(&#39;$0 run foo&#39;, &quot;shiver me timbers, here&#39;s an example for ye&quot;)
  .help(&#39;help&#39;)
  .wrap(70)
  .locale(&#39;pirate&#39;)
  .argv
</code></pre>
<hr>
<pre><code class="language-shell">./test.js - follow ye instructions true

Choose yer command:
  run  Arrr, ya best be knowin&#39; what yer doin&#39;

Options for me hearties!
  --option, -o  &#39;tis a mighty fine option               [requi-yar-ed]
  --help        Parlay this here code of conduct             [boolean]

Ex. marks the spot:
  test.js run foo  shiver me timbers, here&#39;s an example for ye

Ye be havin&#39; to set the followin&#39; argument land lubber: option
</code></pre>
<p>Locales currently supported:</p>
<ul>
<li><strong>de:</strong> German.</li>
<li><strong>en:</strong> American English.</li>
<li><strong>es:</strong> Spanish.</li>
<li><strong>fr:</strong> French.</li>
<li><strong>id:</strong> Indonesian.</li>
<li><strong>it:</strong> Italian.</li>
<li><strong>ja:</strong> Japanese.</li>
<li><strong>ko:</strong> Korean.</li>
<li><strong>nb:</strong> Norwegian Bokmål.</li>
<li><strong>pirate:</strong> American Pirate.</li>
<li><strong>pl:</strong> Polish.</li>
<li><strong>pt:</strong> Portuguese.</li>
<li><strong>pt_BR:</strong> Brazilian Portuguese.</li>
<li><strong>tr:</strong> Turkish.</li>
<li><strong>zh:</strong> Chinese.</li>
</ul>
<p>To submit a new translation for yargs:</p>
<ol>
<li>use <code>./locales/en.json</code> as a starting point.</li>
<li>submit a pull request with the new locale file.</li>
</ol>
<p><em>The <a href="http://www.microsoft.com/Language/en-US/Search.aspx">Microsoft Terminology Search</a> can be useful for finding the correct terminology in your locale.</em></p>
<h2><a name="nargs"></a>.nargs(key, count)</h2><p>The number of arguments that should be consumed after a key. This can be a
useful hint to prevent parsing ambiguity. For example:</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .nargs(&#39;token&#39;, 1)
  .parse([&#39;--token&#39;, &#39;-my-token&#39;]);
</code></pre>
<p>parses as:</p>
<p><code>{ _: [], token: &#39;-my-token&#39;, &#39;$0&#39;: &#39;node test&#39; }</code></p>
<p>Optionally <code>.nargs()</code> can take an object of <code>key</code>/<code>narg</code> pairs.</p>
<h2><a name="normalize"></a>.normalize(key)</h2><p>The key provided represents a path and should have <code>path.normalize()</code> applied.</p>
<h2><a name="number"></a>.number(key)</h2><p>Tell the parser to always interpret <code>key</code> as a number.</p>
<p>If <code>key</code> is an array, all elements will be parsed as numbers.</p>
<p>If the option is given on the command line without a value, <code>argv</code> will be
populated with <code>undefined</code>.</p>
<p>If the value given on the command line cannot be parsed as a number, <code>argv</code> will
be populated with <code>NaN</code>.</p>
<p>Note that decimals, hexadecimals, and scientific notation are all accepted.</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .number(&#39;n&#39;)
  .number([&#39;width&#39;, &#39;height&#39;])
  .argv
</code></pre>
<h2>.option(key, opt)</h2><h2>.options(key, opt)</h2><p>Instead of chaining together <code>.alias().demand().default().describe().string()</code>, you can specify
keys in <code>opt</code> for each of the chainable methods.</p>
<p>For example:</p>
<pre><code class="language-javascript">var argv = require(&#39;yargs&#39;)
    .option(&#39;f&#39;, {
        alias: &#39;file&#39;,
        demand: true,
        default: &#39;/etc/passwd&#39;,
        describe: &#39;x marks the spot&#39;,
        type: &#39;string&#39;
    })
    .argv
;
</code></pre>
<p>is the same as</p>
<pre><code class="language-javascript">var argv = require(&#39;yargs&#39;)
    .alias(&#39;f&#39;, &#39;file&#39;)
    .demand(&#39;f&#39;)
    .default(&#39;f&#39;, &#39;/etc/passwd&#39;)
    .describe(&#39;f&#39;, &#39;x marks the spot&#39;)
    .string(&#39;f&#39;)
    .argv
;
</code></pre>
<p>Optionally <code>.options()</code> can take an object that maps keys to <code>opt</code> parameters.</p>
<pre><code class="language-javascript">var argv = require(&#39;yargs&#39;)
    .options({
      &#39;f&#39;: {
        alias: &#39;file&#39;,
        demand: true,
        default: &#39;/etc/passwd&#39;,
        describe: &#39;x marks the spot&#39;,
        type: &#39;string&#39;
      }
    })
    .argv
;
</code></pre>
<p>Valid <code>opt</code> keys include:</p>
<ul>
<li><code>alias</code>: string or array of strings, alias(es) for the canonical option key, see <a href="#alias"><code>alias()</code></a></li>
<li><code>array</code>: boolean, interpret option as an array, see <a href="#array"><code>array()</code></a></li>
<li><code>boolean</code>: boolean, interpret option as a boolean flag, see <a href="#boolean"><code>boolean()</code></a></li>
<li><code>choices</code>: value or array of values, limit valid option arguments to a predefined set, see <a href="#choices"><code>choices()</code></a></li>
<li><code>config</code>: boolean, interpret option as a path to a JSON config file, see <a href="#config"><code>config()</code></a></li>
<li><code>configParser</code>: function, provide a custom config parsing function, see <a href="#config"><code>config()</code></a></li>
<li><code>count</code>: boolean, interpret option as a count of boolean flags, see <a href="#count"><code>count()</code></a></li>
<li><code>default</code>: value, set a default value for the option, see <a href="#default"><code>default()</code></a></li>
<li><code>defaultDescription</code>: string, use this description for the default value in help content, see <a href="#default"><code>default()</code></a></li>
<li><code>demand</code>/<code>require</code>/<code>required</code>: boolean or string, demand the option be given, with optional error message, see <a href="#demand"><code>demand()</code></a></li>
<li><code>desc</code>/<code>describe</code>/<code>description</code>: string, the option description for help content, see <a href="#describe"><code>describe()</code></a></li>
<li><code>global</code>: boolean, indicate that this key should not be <a href="#reset">reset</a> when a command is invoked, see <a href="#global"><code>global()</code></a></li>
<li><code>group</code>: string, when displaying usage instructions place the option under an alternative group heading, see <a href="#group"><code>group()</code></a></li>
<li><code>nargs</code>: number, specify how many arguments should be consumed for the option, see <a href="#nargs"><code>nargs()</code></a></li>
<li><code>normalize</code>: boolean, apply <code>path.normalize()</code> to the option, see <a href="#normalize"><code>normalize()</code></a></li>
<li><code>number</code>: boolean, interpret option as a number, <a href="#number"><code>number()</code></a></li>
<li><code>requiresArg</code>: boolean, require the option be specified with a value, see <a href="#requiresArg"><code>requiresArg()</code></a></li>
<li><code>skipValidation</code>: boolean, skips validation if the option is present, see <a href="#skipValidation"><code>skipValidation()</code></a></li>
<li><code>string</code>: boolean, interpret option as a string, see <a href="#string"><code>string()</code></a></li>
<li><code>type</code>: one of the following strings<ul>
<li><code>&#39;array&#39;</code>: synonymous for <code>array: true</code>, see <a href="#array"><code>array()</code></a></li>
<li><code>&#39;boolean&#39;</code>: synonymous for <code>boolean: true</code>, see <a href="#boolean"><code>boolean()</code></a></li>
<li><code>&#39;count&#39;</code>: synonymous for <code>count: true</code>, see <a href="#count"><code>count()</code></a></li>
<li><code>&#39;number&#39;</code>: synonymous for <code>number: true</code>, see <a href="#number"><code>number()</code></a></li>
<li><code>&#39;string&#39;</code>: synonymous for <code>string: true</code>, see <a href="#string"><code>string()</code></a></li>
</ul>
</li>
</ul>
<h2>.parse(args)</h2><p>Parse <code>args</code> instead of <code>process.argv</code>. Returns the <code>argv</code> object.</p>
<p><code>args</code> may either be a pre-processed argv array, or a raw argument string.</p>
<h2>.pkgConf(key, [cwd])</h2><p>Similar to <a href="#config"><code>config()</code></a>, indicates that yargs should interpret the object from the specified key in package.json
as a configuration object.</p>
<p><code>cwd</code> can optionally be provided, the package.json will be read
from this location.</p>
<h2>.require(key, [msg | boolean])</h2><h2>.required(key, [msg | boolean])</h2><p>An alias for <a href="#demand"><code>demand()</code></a>. See docs there.</p>
<h2><a name="requiresArg"></a>.requiresArg(key)</h2><p>Specifies either a single option key (string), or an array of options that
must be followed by option values. If any option value is missing, show the
usage information and exit.</p>
<p>The default behavior is to set the value of any key not followed by an
option value to <code>true</code>.</p>
<h2><a name="reset"></a>.reset()</h2><p>Reset the argument object built up so far. This is useful for
creating nested command line interfaces. Use <a href="#global">global</a>
to specify keys that should not be reset.</p>
<pre><code class="language-js">var yargs = require(&#39;yargs&#39;)
  .usage(&#39;$0 command&#39;)
  .command(&#39;hello&#39;, &#39;hello command&#39;)
  .command(&#39;world&#39;, &#39;world command&#39;)
  .demand(1, &#39;must provide a valid command&#39;),
  argv = yargs.argv,
  command = argv._[0];

if (command === &#39;hello&#39;) {
  yargs.reset()
    .usage(&#39;$0 hello&#39;)
    .help(&#39;h&#39;)
    .example(&#39;$0 hello&#39;, &#39;print the hello message!&#39;)
    .argv

  console.log(&#39;hello!&#39;);
} else if (command === &#39;world&#39;){
  yargs.reset()
    .usage(&#39;$0 world&#39;)
    .help(&#39;h&#39;)
    .example(&#39;$0 world&#39;, &#39;print the world message!&#39;)
    .argv

  console.log(&#39;world!&#39;);
} else {
  yargs.showHelp();
}
</code></pre>
<h2>.showCompletionScript()</h2><p>Generate a bash completion script. Users of your application can install this
script in their <code>.bashrc</code>, and yargs will provide completion shortcuts for
commands and options.</p>
<h2>.showHelp(consoleLevel=&#39;error&#39;)</h2><p>Print the usage data using the <a href="https://nodejs.org/api/console.html"><code>console</code></a> function <code>consoleLevel</code> for printing.</p>
<p>Example:</p>
<pre><code class="language-js">var yargs = require(&quot;yargs&quot;)
  .usage(&quot;$0 -operand1 number -operand2 number -operation [add|subtract]&quot;);
yargs.showHelp(); //prints to stderr using console.error()
</code></pre>
<p>Or, to print the usage data to <code>stdout</code> instead, you can specify the use of <code>console.log</code>:</p>
<pre><code class="language-js">yargs.showHelp(&quot;log&quot;); //prints to stdout using console.log()
</code></pre>
<p>Later on, <code>argv</code> can be retrieved with <code>yargs.argv</code>.</p>
<h2>.showHelpOnFail(enable, [message])</h2><p>By default, yargs outputs a usage string if any error is detected. Use the
<code>.showHelpOnFail()</code> method to customize this behavior. If <code>enable</code> is <code>false</code>,
the usage string is not output. If the <code>message</code> parameter is present, this
message is output after the error message.</p>
<p>line_count.js:</p>
<pre><code class="language-javascript">#!/usr/bin/env node
var argv = require(&#39;yargs&#39;)
    .usage(&#39;Count the lines in a file.\nUsage: $0 -f &lt;file&gt;&#39;)
    .demand(&#39;f&#39;)
    .alias(&#39;f&#39;, &#39;file&#39;)
    .describe(&#39;f&#39;, &#39;Load a file&#39;)
    .string(&#39;f&#39;)
    .showHelpOnFail(false, &#39;Specify --help for available options&#39;)
    .help(&#39;help&#39;)
    .argv;

// etc.
</code></pre>
<hr>
<pre><code>$ node line_count.js
Missing argument value: f

Specify --help for available options
</code></pre><h2><a name="skipValidation"></a>.skipValidation(key)</h2><p>Specifies either a single option key (string), or an array of options.
If any of the options is present, yargs validation is skipped.</p>
<h2>.strict()</h2><p>Any command-line argument given that is not demanded, or does not have a
corresponding description, will be reported as an error.</p>
<h2><a name="string"></a>.string(key)</h2><p>Tell the parser logic not to interpret <code>key</code> as a number or boolean.
This can be useful if you need to preserve leading zeros in an input.</p>
<p>If <code>key</code> is an array, interpret all the elements as strings.</p>
<p><code>.string(&#39;_&#39;)</code> will result in non-hyphenated arguments being interpreted as strings,
regardless of whether they resemble numbers.</p>
<h2>.updateLocale(obj)</h2><h2>.updateStrings(obj)</h2><p>Override the default strings used by yargs with the key/value
pairs provided in <code>obj</code>:</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .command(&#39;run&#39;, &#39;the run command&#39;)
  .help(&#39;help&#39;)
  .updateStrings({
    &#39;Commands:&#39;: &#39;My Commands --&gt;\n&#39;
  })
  .wrap(null)
  .argv
</code></pre>
<hr>
<pre><code class="language-shell">My Commands --&gt;

  run  the run command

Options:
  --help  Show help  [boolean]
</code></pre>
<p>If you explicitly specify a <code>locale()</code>, you should do so <em>before</em> calling
<code>updateStrings()</code>.</p>
<h2>.usage(message, [opts])</h2><p>Set a usage message to show which commands to use. Inside <code>message</code>, the string
<code>$0</code> will get interpolated to the current script name or node command for the
present script similar to how <code>$0</code> works in bash or perl.</p>
<p><code>opts</code> is optional and acts like calling <code>.options(opts)</code>.</p>
<h2><a name="version"></a>.version([option], [description], [version])</h2><p>Add an option (e.g. <code>--version</code>) that displays the version number (given by the
<code>version</code> parameter) and exits the process.</p>
<p>If no arguments are passed to <code>version</code> (<code>.version()</code>), yargs will parse the <code>package.json</code>
of your module and use its <code>version</code> value. The default value of <code>option</code> is <code>--version</code>.</p>
<p>You can provide a <code>function</code> for version, rather than a string.
This is useful if you want to use a version stored in a location other than package.json:</p>
<pre><code class="language-js">var argv = require(&#39;yargs&#39;)
  .version(function() {
    return require(&#39;../lib/version&#39;).version;
  })
  .argv;
</code></pre>
<h2><a name="wrap"></a>.wrap(columns)</h2><p>Format usage output to wrap at <code>columns</code> many columns.</p>
<p>By default wrap will be set to <code>Math.min(80, windowWidth)</code>. Use <code>.wrap(null)</code> to
specify no column limit (no right-align). Use <code>.wrap(yargs.terminalWidth())</code> to
maximize the width of yargs&#39; usage instructions.</p>
<h1>parsing tricks</h1><h2>stop parsing</h2><p>Use <code>--</code> to stop parsing flags and stuff the remainder into <code>argv._</code>.</p>
<pre><code>$ node examples/reflect.js -a 1 -b 2 -- -c 3 -d 4
{ _: [ &#39;-c&#39;, &#39;3&#39;, &#39;-d&#39;, &#39;4&#39; ],
  a: 1,
  b: 2,
  &#39;$0&#39;: &#39;examples/reflect.js&#39; }
</code></pre><h2>negate fields</h2><p>If you want to explicitly set a field to false instead of just leaving it
undefined or to override a default you can do <code>--no-key</code>.</p>
<pre><code>$ node examples/reflect.js -a --no-b
{ _: [], a: true, b: false, &#39;$0&#39;: &#39;examples/reflect.js&#39; }
</code></pre><h2>numbers</h2><p>Every argument that looks like a number (<code>!isNaN(Number(arg))</code>) is converted to
one. This way you can just <code>net.createConnection(argv.port)</code> and you can add
numbers out of <code>argv</code> with <code>+</code> without having that mean concatenation,
which is super frustrating.</p>
<h2>duplicates</h2><p>If you specify a flag multiple times it will get turned into an array containing
all the values in order.</p>
<pre><code>$ node examples/reflect.js -x 5 -x 8 -x 0
{ _: [], x: [ 5, 8, 0 ], &#39;$0&#39;: &#39;examples/reflect.js&#39; }
</code></pre><h2>dot notation</h2><p>When you use dots (<code>.</code>s) in argument names, an implicit object path is assumed.
This lets you organize arguments into nested objects.</p>
<pre><code>$ node examples/reflect.js --foo.bar.baz=33 --foo.quux=5
{ _: [],
  foo: { bar: { baz: 33 }, quux: 5 },
  &#39;$0&#39;: &#39;examples/reflect.js&#39; }
</code></pre><h2>short numbers</h2><p>Short numeric <code>-n5</code> style arguments work too:</p>
<pre><code>$ node examples/reflect.js -n123 -m456
{ _: [], n: 123, m: 456, &#39;$0&#39;: &#39;examples/reflect.js&#39; }
</code></pre><h1>installation</h1><p>With <a href="https://github.com/npm/npm">npm</a>, just do:</p>
<pre><code>npm install yargs
</code></pre><p>or clone this project on github:</p>
<pre><code>git clone http://github.com/yargs/yargs.git
</code></pre><p>To run the tests with npm, just do:</p>
<pre><code>npm test
</code></pre><h1>configuration</h1><p>Using the <code>yargs</code> stanza in your <code>package.json</code> you can turn on and off
some of yargs&#39; parsing features:</p>
<pre><code class="language-json">{
  &quot;yargs&quot;: {
    &quot;short-option-groups&quot;: true,
    &quot;camel-case-expansion&quot;: true,
    &quot;dot-notation&quot;: true,
    &quot;parse-numbers&quot;: true,
    &quot;boolean-negation&quot;: true
  }
}
</code></pre>
<p>See the <a href="https://github.com/yargs/yargs-parser#configuration">yargs-parser</a> module
for detailed documentation of this feature.</p>
<h1>inspired by</h1><p>This module is loosely inspired by Perl&#39;s
<a href="http://search.cpan.org/~photo/Getopt-Casual-0.13.1/Casual.pm">Getopt::Casual</a>.</p><footer><div class="grid"><div class="row"><div class="grid-1-1"><p class="text off-white">This the footer</p></div></div></div></footer><script src="bundle.js"></script></body></html>