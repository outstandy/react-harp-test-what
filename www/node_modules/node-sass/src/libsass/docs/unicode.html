<!DOCTYPE html><html><title>Hometown</title><link rel="stylesheet" href="/scss/main.css"><script src="https://fb.me/react-0.14.7.js"></script><script src="https://fb.me/react-dom-0.14.7.js"></script><script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script><script src="https://npmcdn.com/jquery@3.1.0/dist/jquery.min.js"></script><script src="https://npmcdn.com/remarkable@1.6.2/dist/remarkable.min.js"></script><body><nav><div class="grid"><div class="row"><div class="grid-1-1"><a href="#" class="titling type-300 pink">Hometown</a></div></div></div></nav><p>LibSass currently expects all input to be utf8 encoded (and outputs only utf8), if you actually have any unicode characters at all. We do not support conversion between encodings, even if you declare it with a <code>@charset</code> rule. The text below was originally posted as an <a href="https://github.com/sass/libsass/issues/381">issue</a> on the LibSass tracker.</p>
<h3><a href="http://www.w3.org/International/questions/qa-css-charset.en">Declaring character encodings in CSS</a></h3><p>This <a href="http://www.w3.org/International/questions/qa-css-charset.en">explains</a> how the character encoding of a css file is determined. Since we are only dealing with local files, we never have a HTTP header. So the precedence should be &#39;charset&#39; rule, byte-order mark (BOM) or auto-detection (finally falling back to system default/UTF-8). This may not sound too hard to implement, but what about import rules? The CSS specs do not forbid the mixing of different encodings! I solved that by converting all files to UTF-8 internally. On writing there is an option to tell the tool what encoding it should be (UTF-8 by default). One can also define if it should write a BOM or not and if it should add the charset declaration.</p>
<p>Since my tool is written in perl, I have a lot of utilities at hand to deal with different unicode charsets. I&#39;m pretty sure that most OSS uses <a href="https://www.gnu.org/software/libiconv/">libiconv</a> to convert between different encodings. But I have now idea how easy/hard this would be to integrate platform independent (it seems doable).</p>
<h3>Current status on LibSass unicode support</h3><p>Currently LibSass seems to handle the common UTF-8 case pretty well. I believe it should correctly support all ASCII compatible encodings (like UTF-8 or Latin-1). If all includes use the same encoding, the output should be correct (in the same encoding). It should also handle unicode chars in <a href="https://github.com/hcatlin/libsass/issues/244#issuecomment-34681227">selectors, variable names and other identifiers</a>. This is true for all ASCII compatible encodings. So the main incompatible encodings (I&#39;m aware of) are UTF-16/UTF-32 (which could be converted to UTF-8 with libiconv).</p>
<h3>Current encoding auto detection</h3><p>LibSass currently reads all kind of BOMs and will error out if it finds something it doesn&#39;t know how to handle! It seems that it throws away the optional UTF-8 BOM (if any is found). IMO it would be nice if users could configure that (also if a charset rule should be added to the output).</p>
<h3>What is currently not supported</h3><ul>
<li>Using non ASCII compatible encodings (like UTF-16)</li>
<li>Using non ASCII characters in different encodings in different includes</li>
</ul>
<h3>What is missing to support the above cases</h3><ul>
<li>A way to convert between encodings (like libiconv)</li>
<li>Sniffing the charset inside the file (source is available)</li>
<li>Handling the conversion on import (and export)</li>
<li>Optional: Make output encoding configurable</li>
<li>Optional: Add optional/mandatory BOM (configurable)</li>
</ul>
<h3>Low priority feature</h3><p>I guess the current implementation should handle more than 99% of all real world use cases.
A) Unicode characters are still seldomly seen (as they can be written escaped)
B) It will still work if it&#39;s UTF-8 or in any of the most common known western ISO codepages.
Although I&#39;m not sure how this applies to asian and other &quot;exotic&quot; codepages!</p>
<p>I guess the biggest Problem is to have libiconv (or some other) library as a dependency. Since it contains a lot of rules for the conversions, I see it as the only way to handle this correctly. Once that is sorted out it should be pretty much straight forward to implement the missing pieces (in parser.cpp - Parser::parse should return encoding and add Parser::sniff_charset, then convert the source byte stream to UTF-8).</p>
<p>I hope the statements above all hold true. Unicode is really not the easiest topic to wrap your head around. But since I did all the above recently in Perl, I wanted to document it here. Feel free to extend or criticize.</p><footer><div class="grid"><div class="row"><div class="grid-1-1"><p class="text off-white">This the footer</p></div></div></div></footer><script src="bundle.js"></script></body></html>