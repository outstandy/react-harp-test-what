<!DOCTYPE html><html><title>Hometown</title><link rel="stylesheet" href="/scss/main.css"><script src="https://fb.me/react-0.14.7.js"></script><script src="https://fb.me/react-dom-0.14.7.js"></script><script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script><script src="https://npmcdn.com/jquery@3.1.0/dist/jquery.min.js"></script><script src="https://npmcdn.com/remarkable@1.6.2/dist/remarkable.min.js"></script><body><nav><div class="grid"><div class="row"><div class="grid-1-1"><a href="#" class="titling type-300 pink">Hometown</a></div></div></div></nav><p>This document is mainly intended for developers!</p>
<h1>Documenting some of the source map internals</h1><p>Since source maps are somewhat a black box to all LibSass maintainers, <a href="@mgreter">I</a> will try to document my findings with source maps in LibSass, as I come across them. This document will also brievely explain how LibSass parses the source and how it outputs the result.</p>
<p>The main storage for SourceMap mappings is the <code>mappings</code> vector:</p>
<pre><code># in source_map.hpp
vector&lt;Mapping&gt; mappings
# in mappings.hpp
struct Mapping ...
  Position original_position;
  Position generated_position;
</code></pre><h2>Every parsed token has its source associated</h2><p>LibSass uses a lexical parser. Whenever LibSass finds a token of interest, it creates a specific <code>AST_Node</code>, which will hold a reference to the input source with line/column information. <code>AST_Node</code> is the base class for all parsed items. They are declared in <code>ast.hpp</code> and are used in <code>parser.hpp</code>. Here a simple example:</p>
<pre><code>if (lex&lt; custom_property_name &gt;()) {
  Sass::String* prop = new (ctx.mem) String_Constant(path, source_position, lexed);
  return new (ctx.mem) Declaration(path, prop-&gt;position(), prop, ...);
}
</code></pre><h2>How is the <code>source_position</code> calculated</h2><p>This is automatically done with <code>lex</code> in <code>parser.hpp</code>. Whenever something is lexed, the <code>source_position</code> is updated. But be aware that <code>source_position</code> points to the begining of the parsed text. If you need a mapping for the position where the parsing ended, you need to add another call to <code>lex</code> (to match nothing)!</p>
<pre><code>lex&lt; exactly &lt; empty_str &gt; &gt;();
end = new (ctx.mem) String_Constant(path, source_position, lexed);
</code></pre><h2>How are mappings for the output created</h2><p>So far we have collected all needed data for all tokens in the input stream. We can now use this information to create mappings when we put things into the output stream. Mappings are created via the <code>add_mappings</code> method:</p>
<pre><code># in source_map.hpp
void add_mapping(AST_Node* node);
</code></pre><p>This method is called in two places:</p>
<ul>
<li><code>Inspect::append_to_buffer</code></li>
<li><code>Output_[Nested|Compressed]::append_to_buffer</code></li>
</ul>
<p>Mappings can only be created for things that have been parsed into a <code>AST_Node</code>. Otherwise we do not have the information to create the mappings, which is the reason why LibSass currently only maps the most important tokens in source maps.</p><footer><div class="grid"><div class="row"><div class="grid-1-1"><p class="text off-white">This the footer</p></div></div></div></footer><script src="bundle.js"></script></body></html>