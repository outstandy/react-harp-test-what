<!DOCTYPE html><html><title>Hometown</title><link rel="stylesheet" href="/scss/main.css"><script src="https://fb.me/react-0.14.7.js"></script><script src="https://fb.me/react-dom-0.14.7.js"></script><script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script><script src="https://npmcdn.com/jquery@3.1.0/dist/jquery.min.js"></script><script src="https://npmcdn.com/remarkable@1.6.2/dist/remarkable.min.js"></script><body><nav><div class="grid"><div class="row"><div class="grid-1-1"><a href="#" class="titling type-300 pink">Hometown</a></div></div></div></nav><h2>Object Wrappers</h2><p>The <code>ObjectWrap</code> class can be used to make wrapped C++ objects and a factory of wrapped objects.</p>
<ul>
<li><a href="#api_nan_object_wrap"><b><code>Nan::ObjectWrap</code></b></a></li>
</ul>
<p><a name="api_nan_object_wrap"></a></p>
<h3>Nan::ObjectWrap()</h3><p>A reimplementation of <code>node::ObjectWrap</code> that adds some API not present in older versions of Node. Should be preferred over <code>node::ObjectWrap</code> in all cases for consistency.</p>
<p>Definition:</p>
<pre><code class="language-c++">class ObjectWrap {
 public:
  ObjectWrap();

  virtual ~ObjectWrap();

  template &lt;class T&gt;
  static inline T* Unwrap(v8::Local&lt;v8::Object&gt; handle);

  inline v8::Local&lt;v8::Object&gt; handle();

  inline Nan::Persistent&lt;v8::Object&gt;&amp; persistent();

 protected:
  inline void Wrap(v8::Local&lt;v8::Object&gt; handle);

  inline void MakeWeak();

  /* Ref() marks the object as being attached to an event loop.
   * Refed objects will not be garbage collected, even if
   * all references are lost.
   */
  virtual void Ref();

  /* Unref() marks an object as detached from the event loop.  This is its
   * default state.  When an object with a &quot;weak&quot; reference changes from
   * attached to detached state it will be freed. Be careful not to access
   * the object after making this call as it might be gone!
   * (A &quot;weak reference&quot; means an object that only has a
   * persistant handle.)
   *
   * DO NOT CALL THIS FROM DESTRUCTOR
   */
  virtual void Unref();

  int refs_;  // ro
};
</code></pre>
<p>See the Node documentation on <a href="https://nodejs.org/api/addons.html#addons_wrapping_c_objects">Wrapping C++ Objects</a> for more details.</p>
<h3>This vs. Holder</h3><p>When calling <code>Unwrap</code>, it is important that the argument is indeed some JavaScript object which got wrapped by a <code>Wrap</code> call for this class or any derived class.
The <code>Signature</code> installed by <a href="methods.md#api_nan_set_prototype_method"><code>Nan::SetPrototypeMethod()</code></a> does ensure that <code>info.Holder()</code> is just such an instance.
In Node 0.12 and later, <code>info.This()</code> will also be of such a type, since otherwise the invocation will get rejected.
However, in Node 0.10 and before it was possible to invoke a method on a JavaScript object which just had the extension type in its prototype chain.
In such a situation, calling <code>Unwrap</code> on <code>info.This()</code> will likely lead to a failed assertion causing a crash, but could lead to even more serious corruption.</p>
<p>On the other hand, calling <code>Unwrap</code> in an <a href="methods.md#api_nan_set_accessor">accessor</a> should not use <code>Holder()</code> if the accessor is defined on the prototype.
So either define your accessors on the instance template,
or use <code>This()</code> after verifying that it is indeed a valid object.</p>
<h3>Examples</h3><h4>Basic</h4><pre><code class="language-c++">class MyObject : public Nan::ObjectWrap {
 public:
  static NAN_MODULE_INIT(Init) {
    v8::Local&lt;v8::FunctionTemplate&gt; tpl = Nan::New&lt;v8::FunctionTemplate&gt;(New);
    tpl-&gt;SetClassName(Nan::New(&quot;MyObject&quot;).ToLocalChecked());
    tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);

    SetPrototypeMethod(tpl, &quot;getHandle&quot;, GetHandle);
    SetPrototypeMethod(tpl, &quot;getValue&quot;, GetValue);

    constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());
    Nan::Set(target, Nan::New(&quot;MyObject&quot;).ToLocalChecked(),
      Nan::GetFunction(tpl).ToLocalChecked());
  }

 private:
  explicit MyObject(double value = 0) : value_(value) {}
  ~MyObject() {}

  static NAN_METHOD(New) {
    if (info.IsConstructCall()) {
      double value = info[0]-&gt;IsUndefined() ? 0 : Nan::To&lt;double&gt;(info[0]).FromJust();
      MyObject *obj = new MyObject(value);
      obj-&gt;Wrap(info.This());
      info.GetReturnValue().Set(info.This());
    } else {
      const int argc = 1;
      v8::Local&lt;v8::Value&gt; argv[argc] = {info[0]};
      v8::Local&lt;v8::Function&gt; cons = Nan::New(constructor());
      info.GetReturnValue().Set(cons-&gt;NewInstance(argc, argv));
    }
  }

  static NAN_METHOD(GetHandle) {
    MyObject* obj = Nan::ObjectWrap::Unwrap&lt;MyObject&gt;(info.Holder());
    info.GetReturnValue().Set(obj-&gt;handle());
  }

  static NAN_METHOD(GetValue) {
    MyObject* obj = Nan::ObjectWrap::Unwrap&lt;MyObject&gt;(info.Holder());
    info.GetReturnValue().Set(obj-&gt;value_);
  }

  static inline Nan::Persistent&lt;v8::Function&gt; &amp; constructor() {
    static Nan::Persistent&lt;v8::Function&gt; my_constructor;
    return my_constructor;
  }

  double value_;
};

NODE_MODULE(objectwrapper, MyObject::Init)
</code></pre>
<p>To use in Javascript:</p>
<pre><code class="language-Javascript">var objectwrapper = require(&#39;bindings&#39;)(&#39;objectwrapper&#39;);

var obj = new objectwrapper.MyObject(5);
console.log(&#39;Should be 5: &#39; + obj.getValue());
</code></pre>
<h4>Factory of wrapped objects</h4><pre><code class="language-c++">class MyFactoryObject : public Nan::ObjectWrap {
 public:
  static NAN_MODULE_INIT(Init) {
    v8::Local&lt;v8::FunctionTemplate&gt; tpl = Nan::New&lt;v8::FunctionTemplate&gt;(New);
    tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);

    Nan::SetPrototypeMethod(tpl, &quot;getValue&quot;, GetValue);

    constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());
  }

  static NAN_METHOD(NewInstance) {
    v8::Local&lt;v8::Function&gt; cons = Nan::New(constructor());
    double value = info[0]-&gt;IsNumber() ? Nan::To&lt;double&gt;(info[0]).FromJust() : 0;
    const int argc = 1;
    v8::Local&lt;v8::Value&gt; argv[1] = {Nan::New(value)};
    info.GetReturnValue().Set(Nan::NewInstance(cons, argc, argv).ToLocalChecked());
  }

  // Needed for the next example:
  inline double value() const {
    return value_;
  }

 private:
  explicit MyFactoryObject(double value = 0) : value_(value) {}
  ~MyFactoryObject() {}

  static NAN_METHOD(New) {
    if (info.IsConstructCall()) {
      double value = info[0]-&gt;IsNumber() ? Nan::To&lt;double&gt;(info[0]).FromJust() : 0;
      MyFactoryObject * obj = new MyFactoryObject(value);
      obj-&gt;Wrap(info.This());
      info.GetReturnValue().Set(info.This());
    } else {
      const int argc = 1;
      v8::Local&lt;v8::Value&gt; argv[argc] = {info[0]};
      v8::Local&lt;v8::Function&gt; cons = Nan::New(constructor());
      info.GetReturnValue().Set(Nan::NewInstance(cons, argc, argv).ToLocalChecked());
    }
  }

  static NAN_METHOD(GetValue) {
    MyFactoryObject* obj = ObjectWrap::Unwrap&lt;MyFactoryObject&gt;(info.Holder());
    info.GetReturnValue().Set(obj-&gt;value_);
  }

  static inline Nan::Persistent&lt;v8::Function&gt; &amp; constructor() {
    static Nan::Persistent&lt;v8::Function&gt; my_constructor;
    return my_constructor;
  }

  double value_;
};

NAN_MODULE_INIT(Init) {
  MyFactoryObject::Init(target);
  Nan::Set(target,
    Nan::New&lt;v8::String&gt;(&quot;newFactoryObjectInstance&quot;).ToLocalChecked(),
    Nan::GetFunction(
      Nan::New&lt;v8::FunctionTemplate&gt;(MyFactoryObject::NewInstance)).ToLocalChecked()
  );
}

NODE_MODULE(wrappedobjectfactory, Init)
</code></pre>
<p>To use in Javascript:</p>
<pre><code class="language-Javascript">var wrappedobjectfactory = require(&#39;bindings&#39;)(&#39;wrappedobjectfactory&#39;);

var obj = wrappedobjectfactory.newFactoryObjectInstance(10);
console.log(&#39;Should be 10: &#39; + obj.getValue());
</code></pre>
<h4>Passing wrapped objects around</h4><p>Use the <code>MyFactoryObject</code> class above along with the following:</p>
<pre><code class="language-c++">static NAN_METHOD(Sum) {
  Nan::MaybeLocal&lt;v8::Object&gt; maybe1 = Nan::To&lt;v8::Object&gt;(info[0]);
  Nan::MaybeLocal&lt;v8::Object&gt; maybe2 = Nan::To&lt;v8::Object&gt;(info[1]);

  // Quick check:
  if (maybe1.IsEmpty() || maybe2.IsEmpty()) {
    // return value is undefined by default
    return;
  }

  MyFactoryObject* obj1 =
    Nan::ObjectWrap::Unwrap&lt;MyFactoryObject&gt;(maybe1.ToLocalChecked());
  MyFactoryObject* obj2 =
    Nan::ObjectWrap::Unwrap&lt;MyFactoryObject&gt;(maybe2.ToLocalChecked());

  info.GetReturnValue().Set(Nan::New&lt;v8::Number&gt;(obj1-&gt;value() + obj2-&gt;value()));
}

NAN_MODULE_INIT(Init) {
  MyFactoryObject::Init(target);
  Nan::Set(target,
    Nan::New&lt;v8::String&gt;(&quot;newFactoryObjectInstance&quot;).ToLocalChecked(),
    Nan::GetFunction(
      Nan::New&lt;v8::FunctionTemplate&gt;(MyFactoryObject::NewInstance)).ToLocalChecked()
  );
  Nan::Set(target,
    Nan::New&lt;v8::String&gt;(&quot;sum&quot;).ToLocalChecked(),
    Nan::GetFunction(Nan::New&lt;v8::FunctionTemplate&gt;(Sum)).ToLocalChecked()
  );
}

NODE_MODULE(myaddon, Init)
</code></pre>
<p>To use in Javascript:</p>
<pre><code class="language-Javascript">var myaddon = require(&#39;bindings&#39;)(&#39;myaddon&#39;);

var obj1 = myaddon.newFactoryObjectInstance(5);
var obj2 = myaddon.newFactoryObjectInstance(10);
console.log(&#39;sum of object values: &#39; + myaddon.sum(obj1, obj2));
</code></pre><footer><div class="grid"><div class="row"><div class="grid-1-1"><p class="text off-white">This the footer</p></div></div></div></footer><script src="bundle.js"></script></body></html>